{
  "hash": "3bf7d901bb748fafb206caae0566e863",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tutorial 01\"\nformat: live-html\nengine: knitr\n# prevent any project filters from interfering\nfilters: []\nsidebar:\n  style: docked\n  contents:\n    - text: \"Q1 — Sum to 10\"\n      href: \"#q1\"\n    - text: \"Q2 — Division\"\n      href: \"#q2\"\n    - text: \"Q3 — Histogram\"\n      href: \"#q3\"\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n## Q1 — Make the sum equal 10 {#q1}\n\nReplace `＿` with a number so the expression evaluates to **10**.\n\n\n::: {.cell setup='true' exercise='ex_sum'}\n```{webr}\n#| setup: true\n#| exercise: ex_sum\n＿ <- NA_real_\n```\n:::\n\n\n\n::: {.cell exercise='ex_sum'}\n```{webr}\n#| exercise: ex_sum\n1 + 2 + ＿ + ＿\n```\n:::\n\n\n::: {.hint exercise=\"ex_sum\"}\nReplace the two ＿ with 2 numbers that add up to 7.\n:::\n\n::: {.solution exercise=\"ex_sum\"}\n\n::: {.cell exercise='ex_sum' solution='true'}\n```{webr}\n#| exercise: ex_sum\n#| solution: true \n1 + 2 + 3 + 4\n```\n:::\n\n:::\n\n\n::: {.cell exercise='ex_sum' check='true'}\n```{webr}\n#| exercise: ex_sum\n#| check: true\ngradethis::grade_this({\n  if (grepl(\"＿\", .user_code, fixed = TRUE)) {\n    fail(\"Replace ＿ with a number.\")\n  }\n  # Pass if the evaluated result is (numerically) 10\n  if (is.numeric(.result) && length(.result) == 1 &&\n      isTRUE(all.equal(.result, 10))) {\n    pass(\"✅ Correct!\")\n  } else {\n    fail(\"Not quite — try to make the expression evaluate to 10.\")\n  }\n})\n```\n:::\n\n\n## Q2 — Write a function using division {#q2}\n\nDefine a function called `divide_nums` that takes two arguments (`a` and `b`) and returns the results of:\n\n1. `a / b`  \n2. `b / a`  \n\nBoth results should be stored in separate variables before being returned.\n\n\n::: {.callout-note title=\"Info\"}\nRemember: in R, division by zero (1/0) will return Inf rather than an error.\n:::\n\n::: {.callout-note title=\"Info\"}\nIn R, lists are written with list(a, b, c). Each element can be anything: a number, a string, or even another list.\n:::\n\n\n\n::: {.cell exercise='ex_fun_div' exercise.lines='8'}\n```{webr}\n#| exercise: ex_fun_div\n#| exercise.lines: 8\n#| echo: false\ndivide_nums <- function(a, b) {\n  # your code here\n}\n```\n:::\n\n::: {.hint exercise=\"ex_fun_div\"}\nStart with:\nres1 <- a / b\nres2 <- b / a\nlist(res1, res2)\n:::\n\n::: {.solution exercise=\"ex_fun_div\"}\n\n\n::: {.cell exercise='ex_fun_div' solution='true'}\n```{webr}\n#| exercise: ex_fun_div\n#| solution: true\ndivide_nums <- function(a, b) {\n  res1 <- a / b\n  res2 <- b / a\n  list(res1, res2)\n}\n```\n:::\n\n\n:::\n\n\n::: {.cell exercise='ex_fun_div' check='true'}\n```{webr}\n#| exercise: ex_fun_div\n#| check: true\ngradethis::grade_this({\n  code <- .user_code\n\n  # 0) Empty/untouched?\n  if (!nzchar(gsub(\"\\\\s|#.*\", \"\", code))) {\n    fail(\"Type your answer in the editor.\")\n  }\n\n  # 1) Find the student's env (webR/gradethis names vary)\n  env <- get0(\".envir_result\", ifnotfound = NULL)\n  if (is.null(env)) env <- get0(\".user_env\", ifnotfound = NULL)\n  if (is.null(env)) env <- parent.frame()\n\n  # 2) Get their function (prefer the named binding; fall back to .result)\n  f <- NULL\n  if (exists(\"divide_nums\", envir = env, inherits = FALSE)) {\n    f <- get(\"divide_nums\", envir = env)\n  } else if (is.function(.result)) {\n    f <- .result\n  }\n\n  if (!is.function(f)) {\n    fail(\"Define a function named `divide_nums(a, b)` (use `divide_nums <- function(a, b) { ... }`).\")\n  }\n\n  # 3) Run it and grade\n  val <- tryCatch(f(8, 2), error = function(e) e)\n  if (inherits(val, \"error\")) {\n    msg <- conditionMessage(val)\n    if (grepl(\"object .* not found\", msg)) {\n      fail(\"Looks like you referenced a variable that wasn’t created (e.g., `res1` or `res2`).\")\n    } else {\n      fail(paste0(\"Your function raised an error: \", msg))\n    }\n  }\n\n  if (!is.list(val) || length(val) != 2) {\n    fail(\"Return a **list** of two elements: `list(res1, res2)`.\")\n  }\n  if (!(is.numeric(val[[1]]) && is.numeric(val[[2]]))) {\n    fail(\"Both returned values must be numeric (`a/b` and `b/a`).\")\n  }\n\n  ok <- isTRUE(all.equal(val[[1]], 4,    tol = 1e-8)) &&\n        isTRUE(all.equal(val[[2]], 0.25, tol = 1e-8))\n  if (!ok) {\n    fail(\"Close! Compute `res1 <- a / b` and `res2 <- b / a`, then return `list(res1, res2)`.\")\n  }\n\n  pass(\"✅ Well done! Function name, outputs, and return format are correct.\")\n})\n```\n:::\n\n\n## Q3 — Create a vector\n\nMake a vector called `my_vec` that contains the numbers **5, 10, 15, 20**.\n\n\n::: {.cell exercise='ex_vec' exercise.lines='2'}\n```{webr}\n#| exercise: ex_vec\n#| exercise.lines: 2\n#| echo: false\nmy_vec <- NULL\n\n```\n:::\n\n\n::: {.hint exercise=\"ex_vec\"}\nUse the c() function to combine numbers: c(1, 2, 3)\n:::\n\n::: {.solution exercise=\"ex_vec\"}\n\n::: {.cell exercise='ex_vec' solution='true'}\n```{webr}\n#| exercise: ex_vec\n#| solution: true\nmy_vec <- c(5, 10, 15, 20)\n\n```\n:::\n\n\n:::\n\n\n::: {.cell exercise='ex_vec' check='true'}\n```{webr}\n#| exercise: ex_vec\n#| check: true\ngradethis::grade_this({\n  if (!exists(\"my_vec\", envir = .envir_result)) {\n    fail(\"You need to define `my_vec`.\")\n  }\n  v <- get(\"my_vec\", envir = .envir_result)\n  if (!is.numeric(v)) {\n    fail(\"`my_vec` should be numeric.\")\n  }\n  if (!identical(v, c(5, 10, 15, 20))) {\n    fail(\"`my_vec` should contain exactly 5, 10, 15, 20 in that order.\")\n  }\n  pass(\"✅ Nice! Your vector is correct.\")\n})\n\n```\n:::\n\n## Q4 — Find the average\n\nCompute the mean of the vector `c(2, 4, 6, 8, 10)`.  \nYour answer should be stored in a variable called `avg_val`.\n\n\n::: {.cell exercise='ex_mean' exercise.lines='2'}\n```{webr}\n#| exercise: ex_mean\n#| exercise.lines: 2\n#| echo: false\navg_val <- NULL\n```\n:::\n\n\n::: {.hint exercise=\"ex_mean\"}\nUse the mean() function: mean(c(...))\n:::\n\n::: {.solution exercise=\"ex_mean\"}\n\n::: {.cell exercise='ex_mean' solution='true'}\n```{webr}\n#| exercise: ex_mean\n#| solution: true\navg_val <- mean(c(2, 4, 6, 8, 10))\n\n```\n:::\n\n:::\n\n::: {.cell exercise='ex_mean' check='true'}\n```{webr}\n#| exercise: ex_mean\n#| check: true\ngradethis::grade_this({\n  if (!exists(\"avg_val\", envir = .envir_result)) {\n    fail(\"You need to define `avg_val`.\")\n  }\n  v <- get(\"avg_val\", envir = .envir_result)\n  if (!is.numeric(v) || length(v) != 1) {\n    fail(\"`avg_val` should be a single numeric value.\")\n  }\n  if (!isTRUE(all.equal(v, 6, tol = 1e-8))) {\n    fail(\"Not quite — the mean of c(2,4,6,8,10) is 6.\")\n  }\n  pass(\"✅ Correct! You computed the mean successfully.\")\n})\n\n```\n:::\n\n\n## Q5 — Draw a histogram from `cars` (type the full call) {#q3}\n\nUse **exactly one** of these numeric columns and nothing else:  \ndist  **or**  speed\n\n\n::: {.cell exercise='ex_hist_exact'}\n```{webr}\n#| exercise: ex_hist_exact\n# Type your answer on the next line (one command only):\n```\n:::\n\n\n::: {.solution exercise=\"ex_hist_exact\"}\n\n::: {.cell exercise='ex_hist_exact' solution='true'}\n```{webr}\n#| exercise: ex_hist_exact\n#| solution: true\nhist(cars$dist)\n```\n:::\n\n:::\n\n\n::: {.cell exercise='ex_hist_exact' check='true'}\n```{webr}\n#| exercise: ex_hist_exact\n#| check: true\ngradethis::grade_this({\n  # Grab what they typed (keep it robust)\n  code <- .user_code\n  lines <- strsplit(code, \"\\n\", fixed = TRUE)[[1]]\n  # strip comments per-line, then trim and drop empties\n  lines <- sub(\"#.*$\", \"\", lines)\n  trim  <- function(s) sub(\"^\\\\s+|\\\\s+$\", \"\", s)\n  lines <- trim(lines)\n  lines <- lines[nzchar(lines)]\n\n  if (length(lines) == 0) {\n    fail(\"Type your answer, it cant be empty.\")\n  }\n  if (length(lines) > 1) {\n    fail(\"Enter exactly **one** command.\")\n  }\n\n  one <- lines[1]\n  # Did it actually draw a histogram?\n  if (!inherits(.result, \"histogram\")) {\n    fail(\"Your code should draw a histogram.\")\n  }\n\n  # Normalize spaces for exact-match check\n  normalized <- gsub(\"\\\\s+\", \"\", one)\n\n  if (normalized %in% c(\"hist(cars$dist)\", \"hist(cars$speed)\")) {\n    pass(\"✅ Correct!\")\n  } else if (grepl(\"^hist\\\\s*\\\\(\\\\s*cars\\\\s*\\\\)\\\\s*$\", one)) {\n    fail(\"`hist(cars)` won’t work—choose a numeric column: hist(cars$dist) or hist(cars$speed).\")\n  } else if (grepl(\"^hist\\\\s*\\\\(\", one)) {\n    fail(\"For this question, type exactly `hist(cars$dist)` or `hist(cars$speed)` (and nothing else).\")\n  } else {\n    fail(\"Use `hist(...)` with a column from `cars`.\")\n  }\n})\n```\n:::\n\n\n## Q6 — Draw a boxplot from `cars` (type the full call) {#q4}\n\nUse **exactly one** of these numeric columns and nothing else:  \ndist  **or**  speed\n\n\n::: {.cell exercise='ex_boxplot_exact'}\n```{webr}\n#| exercise: ex_boxplot_exact\n# Type your answer on the next line (one command only):\n```\n:::\n\n\n::: {.solution exercise=\"ex_boxplot_exact\"}\n\n::: {.cell exercise='ex_boxplot_exact' solution='true'}\n```{webr}\n#| exercise: ex_boxplot_exact\n#| solution: true\nboxplot(cars$dist)\n```\n:::\n\n:::\n\n\n\n::: {.cell exercise='ex_boxplot_exact' check='true'}\n```{webr}\n#| exercise: ex_boxplot_exact\n#| check: true\ngradethis::grade_this({\n  code <- .user_code\n\n  # Normalize to a single, comment-free line\n  lines <- strsplit(code, \"\\n\", fixed = TRUE)[[1]]\n  lines <- sub(\"#.*$\", \"\", lines)              # strip end-of-line comments\n  trim  <- function(s) sub(\"^\\\\s+|\\\\s+$\", \"\", s)\n  lines <- trim(lines)\n  lines <- lines[nzchar(lines)]\n\n  if (length(lines) == 0) {\n    fail(\"Type your answer, it can't be empty.\")\n  }\n  if (length(lines) > 1) {\n    fail(\"Enter exactly **one** command.\")\n  }\n\n  one <- lines[1]\n\n  # Parse safely (don't rely on .result for plots)\n  expr <- try(parse(text = one)[[1]], silent = TRUE)\n  if (inherits(expr, \"try-error\")) {\n    fail(\"Your code must be a single valid R expression.\")\n  }\n\n  # Must be a call to boxplot(...)\n  if (!(is.call(expr) && identical(as.character(expr[[1]]), \"boxplot\"))) {\n    fail(\"Use `boxplot(...)`.\")\n  }\n\n  # Be strict: exactly one argument, and it must be cars$dist or cars$speed\n  # (students can add spaces; we check the parsed argument)\n  n_args <- length(as.list(expr)) - 1L\n  if (n_args != 1L) {\n    fail(\"For this question, pass exactly **one** argument to `boxplot()`.\")\n  }\n\n  arg <- as.list(expr)[[2]]\n  arg_txt <- paste0(deparse(arg), collapse = \"\")\n  allowed <- c(\"cars$dist\", \"cars$speed\")\n\n  if (arg_txt %in% allowed) {\n    pass(\"✅ Correct!\")\n  } else if (grepl(\"^cars\\\\s*$\", arg_txt)) {\n    fail(\"`boxplot(cars)` won’t work—choose a numeric column: `boxplot(cars$dist)` or `boxplot(cars$speed)`.\")\n  } else {\n    fail(\"For this question, type exactly `boxplot(cars$dist)` or `boxplot(cars$speed)` (and nothing else).\")\n  }\n})\n```\n:::\n\n\n## Q7 — Add a color to the histogram\n\nRe-draw a histogram of **cars$dist** and set **any** bar color using the `col=` argument.\n\n\n::: {.cell exercise='ex_hist_col'}\n```{webr}\n#| exercise: ex_hist_col\n# (one command)\n```\n:::\n\n\n::: {.hint exercise=\"ex_hist_col\"}\nExample: hist(cars$dist, col = \"steelblue\")\n:::\n\n::: {.solution exercise=\"ex _hist_col\"}\n\n\n::: {.cell exercise='ex_hist_col' solution='true'}\n```{webr}\n#| exercise: ex_hist_col\n#| solution: true\nhist(cars$dist, col = \"steelblue\")\n```\n:::\n\n:::\n\n\n::: {.cell exercise='ex_hist_col' check='true'}\n```{webr}\n#| exercise: ex_hist_col\n#| check: true\ngradethis::grade_this({\n  line <- paste(.user_code, collapse = \"\\n\")\n  msgs <- c()\n\n  if (!inherits(.result, \"histogram\")) fail(\"Use `hist(...)` to draw a histogram of `cars$dist`.\")\n  msgs <- c(msgs, \"✅ drew a histogram.\")\n\n  if (!grepl(\"hist\\\\s*\\\\(\\\\s*cars\\\\s*\\\\$\\\\s*dist\", line)) msgs <- c(msgs, \"❌ use `cars$dist`.\") else msgs <- c(msgs, \"✅ used `cars$dist`.\")\n  if (!grepl(\"col\\\\s*=\", line)) msgs <- c(msgs, \"❌ add a color with `col = ...`.\") else msgs <- c(msgs, \"✅ specified a color (`col = ...`).\")\n\n  if (all(grepl(\"^✅\", msgs))) pass(paste(msgs, collapse = \"\\n\")) else fail(paste(msgs, collapse = \"\\n\"))\n})\n```\n:::\n\n\n\n## Q8 — Boxplot (make it horizontal)\n\nDraw a boxplot of **cars$speed** and make it **horizontal** using the `horizontal = TRUE` argument.\n\n\n::: {.cell exercise='ex_box_h'}\n```{webr}\n#| exercise: ex_box_h\n# (one command)\n```\n:::\n\n\n::: {.hint exercise=\"ex_box_h\"}\nExample: boxplot(cars$speed, horizontal = TRUE)\n:::\n\n::: {.solution exercise=\"ex_box_h\"}\n\n\n::: {.cell exercise='ex_box_h' solution='true'}\n```{webr}\n#| exercise: ex_box_h\n#| solution: true\nboxplot(cars$speed, horizontal = TRUE)\n```\n:::\n\n:::\n\n\n::: {.cell exercise='ex_box_h' check='true'}\n```{webr}\n#| exercise: ex_box_h\n#| check: true\ngradethis::grade_this({\n  line <- gsub(\"\\\\s+\", \" \", paste(.user_code, collapse = \" \"))\n  msgs <- c()\n\n  # Did they call boxplot?\n  if (!grepl(\"\\\\bboxplot\\\\s*\\\\(\", line)) {\n    fail(\"Use `boxplot(...)` to draw a boxplot.\")\n  } else {\n    msgs <- c(msgs, \"✅ called `boxplot(...)`.\")\n  }\n\n  # Correct data column?\n  if (!grepl(\"boxplot\\\\s*\\\\(\\\\s*cars\\\\s*\\\\$\\\\s*speed\", line)) {\n    msgs <- c(msgs, \"❌ use `cars$speed`.\")\n  } else {\n    msgs <- c(msgs, \"✅ used `cars$speed`.\")\n  }\n\n  # Horizontal = TRUE (accept T/TRUE, any spacing)\n  if (!grepl(\"horizontal\\\\s*=\\\\s*(TRUE|T)\\\\b\", line)) {\n    msgs <- c(msgs, \"❌ add `horizontal = TRUE`.\")\n  } else {\n    msgs <- c(msgs, \"✅ made it horizontal.\")\n  }\n\n  # Structural sanity check on result (base boxplot returns a list with $stats)\n  if (!(is.list(.result) && !is.null(.result$stats))) {\n    msgs <- c(msgs, \"⚠️ sanity check: result doesn’t look like a base boxplot object; ensure you used base `boxplot()`.\")\n  }\n\n  if (all(grepl(\"^✅\", msgs))) {\n    pass(paste(msgs, collapse = \"\\n\"))\n  } else {\n    fail(paste(msgs, collapse = \"\\n\"))\n  }\n})\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}