{
  "hash": "787d0862a556726ceb9d9bd9d54f7a4e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tutorial 01\"\nformat: live-html\nengine: knitr\n# prevent any project filters from interfering\nfilters: []\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\n## Q1 — Make the sum equal 10 {#q1}\n\nReplace `＿` with a number so the expression evaluates to **10**.\n\n\n::: {.cell setup='true' exercise='ex_sum'}\n```{webr}\n#| setup: true\n#| exercise: ex_sum\n＿ <- NA_real_\n```\n:::\n\n\n\n::: {.cell exercise='ex_sum'}\n```{webr}\n#| exercise: ex_sum\n1 + 2 + ＿ + ＿\n```\n:::\n\n\n::: {.hint exercise=\"ex_sum\"}\nReplace the two ＿ with 2 numbers that add up to 7.\n:::\n\n::: {.solution exercise=\"ex_sum\"}\n\n::: {.cell exercise='ex_sum' solution='true'}\n```{webr}\n#| exercise: ex_sum\n#| solution: true\n1 + 2 + 3 + 4\n```\n:::\n\n:::\n\n\n::: {.cell exercise='ex_sum' check='true'}\n```{webr}\n#| exercise: ex_sum\n#| check: true\ngradethis::grade_this({\n  if (grepl(\"\\\\b＿\\\\b\", .user_code)) {\n    fail(\"Replace ＿ with a number.\")\n  }\n  # Pass if the evaluated result is (numerically) 10\n  if (is.numeric(.result) && length(.result) == 1 &&\n      isTRUE(all.equal(.result, 10))) {\n    pass(\"✅ Correct!\")\n  } else {\n    fail(\"Not quite — try to make the expression evaluate to 10.\")\n  }\n})\n```\n:::\n\n\n## Q2 — Write a function using division {#q2}\n\nDefine a function called `divide_nums` that takes two arguments (`a` and `b`) and returns the results of:\n\n1. `a / b`  \n2. `b / a`  \n\nBoth results should be stored in separate variables before being returned.\n\n\n::: {.callout-note title=\"Info\"}\nRemember: in R, division by zero (1/0) will return Inf rather than an error.\n:::\n\n::: {.callout-note title=\"Info\"}\nIn R, lists are written with list(a, b, c). Each element can be anything: a number, a string, or even another list.\n:::\n\n\n\n::: {.cell exercise='ex_fun_div' exercise.lines='8'}\n```{webr}\n#| exercise: ex_fun_div\n#| exercise.lines: 8\n#| echo: false\ndivide_nums <- function(a, b) {\n  # your code here\n}\n```\n:::\n\n::: {.hint exercise=\"ex_fun_div\"}\nStart with:\nres1 <- a / b\nres2 <- b / a\nlist(res1, res2)\n:::\n\n::: {.solution exercise=\"ex_fun_div\"}\n\n\n::: {.cell exercise='ex_fun_div' solution='true'}\n```{webr}\n#| exercise: ex_fun_div\n#| solution: true\ndivide_nums <- function(a, b) {\n  res1 <- a / b\n  res2 <- b / a\n  list(res1, res2)\n}\n```\n:::\n\n\n:::\n\n\n::: {.cell exercise='ex_fun_div' check='true'}\n```{webr}\n#| exercise: ex_fun_div\n#| check: true\ngradethis::grade_this({\n  code <- .user_code\n\n  # 0) Empty/untouched?\n  if (!nzchar(gsub(\"\\\\s|#.*\", \"\", code))) {\n    fail(\"Type your answer in the editor.\")\n  }\n\n  # 1) Find the student's env (webR/gradethis names vary)\n  env <- get0(\".envir_result\", ifnotfound = NULL)\n  if (is.null(env)) env <- get0(\".user_env\", ifnotfound = NULL)\n  if (is.null(env)) env <- parent.frame()\n\n  # 2) Get their function (prefer the named binding; fall back to .result)\n  f <- NULL\n  if (exists(\"divide_nums\", envir = env, inherits = FALSE)) {\n    f <- get(\"divide_nums\", envir = env)\n  } else if (is.function(.result)) {\n    f <- .result\n  }\n\n  if (!is.function(f)) {\n    fail(\"Define a function named `divide_nums(a, b)` (use `divide_nums <- function(a, b) { ... }`).\")\n  }\n\n  # 3) Run it and grade\n  val <- tryCatch(f(8, 2), error = function(e) e)\n  if (inherits(val, \"error\")) {\n    msg <- conditionMessage(val)\n    if (grepl(\"object .* not found\", msg)) {\n      fail(\"Looks like you referenced a variable that wasn’t created (e.g., `res1` or `res2`).\")\n    } else {\n      fail(paste0(\"Your function raised an error: \", msg))\n    }\n  }\n\n  if (!is.list(val) || length(val) != 2) {\n    fail(\"Return a **list** of two elements: `list(res1, res2)`.\")\n  }\n  if (!(is.numeric(val[[1]]) && is.numeric(val[[2]]))) {\n    fail(\"Both returned values must be numeric (`a/b` and `b/a`).\")\n  }\n\n  ok <- isTRUE(all.equal(val[[1]], 4,    tol = 1e-8)) &&\n        isTRUE(all.equal(val[[2]], 0.25, tol = 1e-8))\n  if (!ok) {\n    fail(\"Close! Compute `res1 <- a / b` and `res2 <- b / a`, then return `list(res1, res2)`.\")\n  }\n\n  pass(\"✅ Well done! Function name, outputs, and return format are correct.\")\n})\n```\n:::\n\n\n## Q3 — Draw a histogram from `cars` (type the full call) {#q3}\n\nUse **exactly one** of these numeric columns and nothing else:  \ndist  **or**  speed\n\n\n::: {.cell exercise='ex_hist_exact'}\n```{webr}\n#| exercise: ex_hist_exact\n# Type your answer on the next line (one command only):\n```\n:::\n\n\n::: {.solution exercise=\"ex_hist_exact\"}\n\n::: {.cell exercise='ex_hist_exact' solution='true'}\n```{webr}\n#| exercise: ex_hist_exact\n#| solution: true\nhist(cars$dist)\n```\n:::\n\n:::\n\n\n::: {.cell exercise='ex_hist_exact' check='true'}\n```{webr}\n#| exercise: ex_hist_exact\n#| check: true\ngradethis::grade_this({\n  # Grab what they typed (keep it robust)\n  code <- .user_code\n  lines <- strsplit(code, \"\\n\", fixed = TRUE)[[1]]\n  # strip comments per-line, then trim and drop empties\n  lines <- sub(\"#.*$\", \"\", lines)\n  trim  <- function(s) sub(\"^\\\\s+|\\\\s+$\", \"\", s)\n  lines <- trim(lines)\n  lines <- lines[nzchar(lines)]\n\n  if (length(lines) == 0) {\n    fail(\"Type your answer, it cant be empty.\")\n  }\n  if (length(lines) > 1) {\n    fail(\"Enter exactly **one** command.\")\n  }\n\n  one <- lines[1]\n  # Did it actually draw a histogram?\n  if (!inherits(.result, \"histogram\")) {\n    fail(\"Your code should draw a histogram.\")\n  }\n\n  # Normalize spaces for exact-match check\n  normalized <- gsub(\"\\\\s+\", \"\", one)\n\n  if (normalized %in% c(\"hist(cars$dist)\", \"hist(cars$speed)\")) {\n    pass(\"✅ Correct!\")\n  } else if (grepl(\"^hist\\\\s*\\\\(\\\\s*cars\\\\s*\\\\)\\\\s*$\", one)) {\n    fail(\"`hist(cars)` won’t work—choose a numeric column: hist(cars$dist) or hist(cars$speed).\")\n  } else if (grepl(\"^hist\\\\s*\\\\(\", one)) {\n    fail(\"For this question, type exactly `hist(cars$dist)` or `hist(cars$speed)` (and nothing else).\")\n  } else {\n    fail(\"Use `hist(...)` with a column from `cars`.\")\n  }\n})\n```\n:::\n\n\n## Q6 — Draw a boxplot from `cars` (type the full call) {#q4}\n\nUse **exactly one** of these numeric columns and nothing else:  \ndist  **or**  speed\n\n\n::: {.cell exercise='ex_boxplot_exact'}\n```{webr}\n#| exercise: ex_boxplot_exact\n# Type your answer on the next line (one command only):\n```\n:::\n\n\n::: {.solution exercise=\"ex_boxplot_exact\"}\n\n::: {.cell exercise='ex_boxplot_exact' solution='true'}\n```{webr}\n#| exercise: ex_boxplot_exact\n#| solution: true\nboxplot(cars$dist)\n```\n:::\n\n:::\n\n\n\n::: {.cell exercise='ex_boxplot_exact' check='true'}\n```{webr}\n#| exercise: ex_boxplot_exact\n#| check: true\ngradethis::grade_this({\n  code <- .user_code\n\n  # Normalize to a single, comment-free line\n  lines <- strsplit(code, \"\\n\", fixed = TRUE)[[1]]\n  lines <- sub(\"#.*$\", \"\", lines)              # strip end-of-line comments\n  trim  <- function(s) sub(\"^\\\\s+|\\\\s+$\", \"\", s)\n  lines <- trim(lines)\n  lines <- lines[nzchar(lines)]\n\n  if (length(lines) == 0) {\n    fail(\"Type your answer, it can't be empty.\")\n  }\n  if (length(lines) > 1) {\n    fail(\"Enter exactly **one** command.\")\n  }\n\n  one <- lines[1]\n\n  # Parse safely (don't rely on .result for plots)\n  expr <- try(parse(text = one)[[1]], silent = TRUE)\n  if (inherits(expr, \"try-error\")) {\n    fail(\"Your code must be a single valid R expression.\")\n  }\n\n  # Must be a call to boxplot(...)\n  if (!(is.call(expr) && identical(as.character(expr[[1]]), \"boxplot\"))) {\n    fail(\"Use `boxplot(...)`.\")\n  }\n\n  # Be strict: exactly one argument, and it must be cars$dist or cars$speed\n  # (students can add spaces; we check the parsed argument)\n  n_args <- length(as.list(expr)) - 1L\n  if (n_args != 1L) {\n    fail(\"For this question, pass exactly **one** argument to `boxplot()`.\")\n  }\n\n  arg <- as.list(expr)[[2]]\n  arg_txt <- paste0(deparse(arg), collapse = \"\")\n  allowed <- c(\"cars$dist\", \"cars$speed\")\n\n  if (arg_txt %in% allowed) {\n    pass(\"✅ Correct!\")\n  } else if (grepl(\"^cars\\\\s*$\", arg_txt)) {\n    fail(\"`boxplot(cars)` won’t work—choose a numeric column: `boxplot(cars$dist)` or `boxplot(cars$speed)`.\")\n  } else {\n    fail(\"For this question, type exactly `boxplot(cars$dist)` or `boxplot(cars$speed)` (and nothing else).\")\n  }\n})\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}