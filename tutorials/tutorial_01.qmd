---
title: "Tutorial 01"
format: live-html
engine: knitr
# prevent any project filters from interfering
filters: []
sidebar:
  style: docked
  contents:
    - text: "Q1 — Sum to 10"
      href: "#q1"
    - text: "Q2 — Division"
      href: "#q2"
    - text: "Q3 — Histogram"
      href: "#q3"
---

{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}
{{< include ../_extensions/r-wasm/live/_gradethis.qmd >}}

## Q1 — Make the sum equal 10 {#q1}

Replace `＿` with a number so the expression evaluates to **10**.

```{webr}
#| setup: true
#| exercise: ex_sum
＿ <- NA_real_
```

```{webr}
#| exercise: ex_sum
1 + 2 + ＿ + ＿
```

::: {.hint exercise="ex_sum"}
Replace the two ＿ with 2 numbers that add up to 7.
:::

::: {.solution exercise="ex_sum"}
```{webr}
#| exercise: ex_sum
#| solution: true
1 + 2 + 3 + 4
```
:::

```{webr}
#| exercise: ex_sum
#| check: true
gradethis::grade_this({
  if (grepl("＿", .user_code, fixed = TRUE)) {
    fail("Replace ＿ with a number.")
  }
  # Pass if the evaluated result is (numerically) 10
  if (is.numeric(.result) && length(.result) == 1 &&
      isTRUE(all.equal(.result, 10))) {
    pass("✅ Correct!")
  } else {
    fail("Not quite — try to make the expression evaluate to 10.")
  }
})
```

## Q2 — Write a function using division {#q2}

Define a function called `divide_nums` that takes two arguments (`a` and `b`) and returns the results of:

1. `a / b`  
2. `b / a`  

Both results should be stored in separate variables before being returned.


::: {.callout-note title="Info"}
Remember: in R, division by zero (1/0) will return Inf rather than an error.
:::

::: {.callout-note title="Info"}
In R, lists are written with list(a, b, c). Each element can be anything: a number, a string, or even another list.
:::


```{webr}
#| exercise: ex_fun_div
#| exercise.lines: 8
#| echo: false
divide_nums <- function(a, b) {
  # your code here
}
```
::: {.hint exercise="ex_fun_div"}
Start with:
res1 <- a / b
res2 <- b / a
list(res1, res2)
:::

::: {.solution exercise="ex_fun_div"}

```{webr}
#| exercise: ex_fun_div
#| solution: true
divide_nums <- function(a, b) {
  res1 <- a / b
  res2 <- b / a
  list(res1, res2)
}
```

:::

```{webr}
#| exercise: ex_fun_div
#| check: true
gradethis::grade_this({
  code <- .user_code

  # 0) Empty/untouched?
  if (!nzchar(gsub("\\s|#.*", "", code))) {
    fail("Type your answer in the editor.")
  }

  # 1) Find the student's env (webR/gradethis names vary)
  env <- get0(".envir_result", ifnotfound = NULL)
  if (is.null(env)) env <- get0(".user_env", ifnotfound = NULL)
  if (is.null(env)) env <- parent.frame()

  # 2) Get their function (prefer the named binding; fall back to .result)
  f <- NULL
  if (exists("divide_nums", envir = env, inherits = FALSE)) {
    f <- get("divide_nums", envir = env)
  } else if (is.function(.result)) {
    f <- .result
  }

  if (!is.function(f)) {
    fail("Define a function named `divide_nums(a, b)` (use `divide_nums <- function(a, b) { ... }`).")
  }

  # 3) Run it and grade
  val <- tryCatch(f(8, 2), error = function(e) e)
  if (inherits(val, "error")) {
    msg <- conditionMessage(val)
    if (grepl("object .* not found", msg)) {
      fail("Looks like you referenced a variable that wasn’t created (e.g., `res1` or `res2`).")
    } else {
      fail(paste0("Your function raised an error: ", msg))
    }
  }

  if (!is.list(val) || length(val) != 2) {
    fail("Return a **list** of two elements: `list(res1, res2)`.")
  }
  if (!(is.numeric(val[[1]]) && is.numeric(val[[2]]))) {
    fail("Both returned values must be numeric (`a/b` and `b/a`).")
  }

  ok <- isTRUE(all.equal(val[[1]], 4,    tol = 1e-8)) &&
        isTRUE(all.equal(val[[2]], 0.25, tol = 1e-8))
  if (!ok) {
    fail("Close! Compute `res1 <- a / b` and `res2 <- b / a`, then return `list(res1, res2)`.")
  }

  pass("✅ Well done! Function name, outputs, and return format are correct.")
})
```

## Q3 — Create a vector

Make a vector called `my_vec` that contains the numbers **5, 10, 15, 20**.

```{webr}
#| exercise: ex_vec
#| exercise.lines: 2
#| echo: false
my_vec <- NULL

```

::: {.hint exercise="ex_vec"}
Use the c() function to combine numbers: c(1, 2, 3)
:::

::: {.solution exercise="ex_vec"}
```{webr}
#| exercise: ex_vec
#| solution: true
my_vec <- c(5, 10, 15, 20)

```

:::

```{webr}
#| exercise: ex_vec
#| check: true
gradethis::grade_this({
  if (!exists("my_vec", envir = .envir_result)) {
    fail("You need to define `my_vec`.")
  }
  v <- get("my_vec", envir = .envir_result)
  if (!is.numeric(v)) {
    fail("`my_vec` should be numeric.")
  }
  if (!identical(v, c(5, 10, 15, 20))) {
    fail("`my_vec` should contain exactly 5, 10, 15, 20 in that order.")
  }
  pass("✅ Nice! Your vector is correct.")
})

```
## Q4 — Find the average

Compute the mean of the vector `c(2, 4, 6, 8, 10)`.  
Your answer should be stored in a variable called `avg_val`.

```{webr}
#| exercise: ex_mean
#| exercise.lines: 2
#| echo: false
avg_val <- NULL
```

::: {.hint exercise="ex_mean"}
Use the mean() function: mean(c(...))
:::

::: {.solution exercise="ex_mean"}
```{webr}
#| exercise: ex_mean
#| solution: true
avg_val <- mean(c(2, 4, 6, 8, 10))

```
:::
```{webr}
#| exercise: ex_mean
#| check: true
gradethis::grade_this({
  if (!exists("avg_val", envir = .envir_result)) {
    fail("You need to define `avg_val`.")
  }
  v <- get("avg_val", envir = .envir_result)
  if (!is.numeric(v) || length(v) != 1) {
    fail("`avg_val` should be a single numeric value.")
  }
  if (!isTRUE(all.equal(v, 6, tol = 1e-8))) {
    fail("Not quite — the mean of c(2,4,6,8,10) is 6.")
  }
  pass("✅ Correct! You computed the mean successfully.")
})

```

## Q5 — Draw a histogram from `cars` (type the full call) {#q3}

Use **exactly one** of these numeric columns and nothing else:  
dist  **or**  speed

```{webr}
#| exercise: ex_hist_exact
# Type your answer on the next line (one command only):
```

::: {.solution exercise="ex_hist_exact"}
```{webr}
#| exercise: ex_hist_exact
#| solution: true
hist(cars$dist)
```
:::

```{webr}
#| exercise: ex_hist_exact
#| check: true
gradethis::grade_this({
  # Grab what they typed (keep it robust)
  code <- .user_code
  lines <- strsplit(code, "\n", fixed = TRUE)[[1]]
  # strip comments per-line, then trim and drop empties
  lines <- sub("#.*$", "", lines)
  trim  <- function(s) sub("^\\s+|\\s+$", "", s)
  lines <- trim(lines)
  lines <- lines[nzchar(lines)]

  if (length(lines) == 0) {
    fail("Type your answer, it cant be empty.")
  }
  if (length(lines) > 1) {
    fail("Enter exactly **one** command.")
  }

  one <- lines[1]
  # Did it actually draw a histogram?
  if (!inherits(.result, "histogram")) {
    fail("Your code should draw a histogram.")
  }

  # Normalize spaces for exact-match check
  normalized <- gsub("\\s+", "", one)

  if (normalized %in% c("hist(cars$dist)", "hist(cars$speed)")) {
    pass("✅ Correct!")
  } else if (grepl("^hist\\s*\\(\\s*cars\\s*\\)\\s*$", one)) {
    fail("`hist(cars)` won’t work—choose a numeric column: hist(cars$dist) or hist(cars$speed).")
  } else if (grepl("^hist\\s*\\(", one)) {
    fail("For this question, type exactly `hist(cars$dist)` or `hist(cars$speed)` (and nothing else).")
  } else {
    fail("Use `hist(...)` with a column from `cars`.")
  }
})
```

## Q6 — Draw a boxplot from `cars` (type the full call) {#q4}

Use **exactly one** of these numeric columns and nothing else:  
dist  **or**  speed

```{webr}
#| exercise: ex_boxplot_exact
# Type your answer on the next line (one command only):
```

::: {.solution exercise="ex_boxplot_exact"}
```{webr}
#| exercise: ex_boxplot_exact
#| solution: true
boxplot(cars$dist)
```
:::


```{webr}
#| exercise: ex_boxplot_exact
#| check: true
gradethis::grade_this({
  code <- .user_code

  # Normalize to a single, comment-free line
  lines <- strsplit(code, "\n", fixed = TRUE)[[1]]
  lines <- sub("#.*$", "", lines)              # strip end-of-line comments
  trim  <- function(s) sub("^\\s+|\\s+$", "", s)
  lines <- trim(lines)
  lines <- lines[nzchar(lines)]

  if (length(lines) == 0) {
    fail("Type your answer, it can't be empty.")
  }
  if (length(lines) > 1) {
    fail("Enter exactly **one** command.")
  }

  one <- lines[1]

  # Parse safely (don't rely on .result for plots)
  expr <- try(parse(text = one)[[1]], silent = TRUE)
  if (inherits(expr, "try-error")) {
    fail("Your code must be a single valid R expression.")
  }

  # Must be a call to boxplot(...)
  if (!(is.call(expr) && identical(as.character(expr[[1]]), "boxplot"))) {
    fail("Use `boxplot(...)`.")
  }

  # Be strict: exactly one argument, and it must be cars$dist or cars$speed
  # (students can add spaces; we check the parsed argument)
  n_args <- length(as.list(expr)) - 1L
  if (n_args != 1L) {
    fail("For this question, pass exactly **one** argument to `boxplot()`.")
  }

  arg <- as.list(expr)[[2]]
  arg_txt <- paste0(deparse(arg), collapse = "")
  allowed <- c("cars$dist", "cars$speed")

  if (arg_txt %in% allowed) {
    pass("✅ Correct!")
  } else if (grepl("^cars\\s*$", arg_txt)) {
    fail("`boxplot(cars)` won’t work—choose a numeric column: `boxplot(cars$dist)` or `boxplot(cars$speed)`.")
  } else {
    fail("For this question, type exactly `boxplot(cars$dist)` or `boxplot(cars$speed)` (and nothing else).")
  }
})
```

## Q7 — Add a color to the histogram

Re-draw a histogram of **cars$dist** and set **any** bar color using the `col=` argument.

```{webr}
#| exercise: ex_hist_col
# (one command)
```

::: {.hint exercise="ex_hist_col"}
Example: hist(cars$dist, col = "steelblue")
:::

::: {.solution exercise="ex_hist_col"}

```{webr}
#| exercise: ex_hist_col
#| solution: true
hist(cars$dist, col = "steelblue")
```
:::

```{webr}
#| exercise: ex_hist_col
#| check: true
gradethis::grade_this({
  line <- paste(.user_code, collapse = "\n")
  msgs <- c()

  if (!inherits(.result, "histogram")) fail("Use `hist(...)` to draw a histogram of `cars$dist`.")
  msgs <- c(msgs, "✅ drew a histogram.")

  if (!grepl("hist\\s*\\(\\s*cars\\s*\\$\\s*dist", line)) msgs <- c(msgs, "❌ use `cars$dist`.") else msgs <- c(msgs, "✅ used `cars$dist`.")
  if (!grepl("col\\s*=", line)) msgs <- c(msgs, "❌ add a color with `col = ...`.") else msgs <- c(msgs, "✅ specified a color (`col = ...`).")

  if (all(grepl("^✅", msgs))) pass(paste(msgs, collapse = "\n")) else fail(paste(msgs, collapse = "\n"))
})
```


## Q8 — Boxplot (make it horizontal)

Draw a boxplot of **cars$speed** and make it **horizontal** using the `horizontal = TRUE` argument.

```{webr}
#| exercise: ex_box_h
# (one command)
```

::: {.hint exercise="ex_box_h"}
Example: boxplot(cars$speed, horizontal = TRUE)
:::

::: {.solution exercise="ex_box_h"}

```{webr}
#| exercise: ex_box_h
#| solution: true
boxplot(cars$speed, horizontal = TRUE)
```
:::

```{webr}
#| exercise: ex_box_h
#| check: true
gradethis::grade_this({
  line <- gsub("\\s+", " ", paste(.user_code, collapse = " "))
  msgs <- c()

  # Did they call boxplot?
  if (!grepl("\\bboxplot\\s*\\(", line)) {
    fail("Use `boxplot(...)` to draw a boxplot.")
  } else {
    msgs <- c(msgs, "✅ called `boxplot(...)`.")
  }

  # Correct data column?
  if (!grepl("boxplot\\s*\\(\\s*cars\\s*\\$\\s*speed", line)) {
    msgs <- c(msgs, "❌ use `cars$speed`.")
  } else {
    msgs <- c(msgs, "✅ used `cars$speed`.")
  }

  # Horizontal = TRUE (accept T/TRUE, any spacing)
  if (!grepl("horizontal\\s*=\\s*(TRUE|T)\\b", line)) {
    msgs <- c(msgs, "❌ add `horizontal = TRUE`.")
  } else {
    msgs <- c(msgs, "✅ made it horizontal.")
  }

  # Structural sanity check on result (base boxplot returns a list with $stats)
  if (!(is.list(.result) && !is.null(.result$stats))) {
    msgs <- c(msgs, "⚠️ sanity check: result doesn’t look like a base boxplot object; ensure you used base `boxplot()`.")
  }

  if (all(grepl("^✅", msgs))) {
    pass(paste(msgs, collapse = "\n"))
  } else {
    fail(paste(msgs, collapse = "\n"))
  }
})
```

