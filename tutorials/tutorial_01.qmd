---
title: "Tutorial 01"
format: live-html
engine: knitr
# prevent any project filters from interfering
filters: []
---

{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}
{{< include ../_extensions/r-wasm/live/_gradethis.qmd >}}

## Q1 — Make the sum equal 10

Replace `＿` with a number so the expression evaluates to **10**.

```{webr}
#| setup: true
#| exercise: ex_sum
＿ <- NA_real_
```

```{webr}
#| exercise: ex_sum
1 + 2 + ＿ + ＿
```

::: {.hint exercise="ex_sum"}
Replace the two ＿ with 2 numbers that add up to 7.
:::

::: {.solution exercise="ex_sum"}
```{webr}
#| exercise: ex_sum
#| solution: true
1 + 2 + 3 + 4
```
:::

```{webr}
#| exercise: ex_sum
#| check: true
gradethis::grade_this({
  if (grepl("\\b＿\\b", .user_code)) {
    fail("Replace ＿ with a number.")
  }
  # Pass if the evaluated result is (numerically) 10
  if (is.numeric(.result) && length(.result) == 1 &&
      isTRUE(all.equal(.result, 10))) {
    pass("✅ Correct!")
  } else {
    fail("Not quite — try to make the expression evaluate to 10.")
  }
})
```

## Q2 — Write a function using division

Define a function called `divide_nums` that takes two arguments (`a` and `b`) and returns the results of:

1. `a / b`  
2. `b / a`  

Both results should be stored in separate variables before being returned.


::: {.callout-note title="Info"}
Remember: in R, division by zero (1/0) will return Inf rather than an error.
:::

::: {.callout-note title="Info"}
In R, lists are written with list(a, b, c). Each element can be anything: a number, a string, or even another list.
:::


```{webr}
#| exercise: ex_fun_div
#| exercise.lines: 8
#| echo: false
divide_nums <- function(a, b) {
  # your code here
}
```
::: {.hint exercise="ex_fun_div"}
Start with:
res1 <- a / b
res2 <- b / a
list(res1, res2)
:::

::: {.solution exercise="ex_fun_div"}

```{webr}
#| exercise: ex_fun_div
#| solution: true
divide_nums <- function(a, b) {
  res1 <- a / b
  res2 <- b / a
  list(res1, res2)
}
```

:::

```{webr}
#| exercise: ex_fun_div
#| check: true
gradethis::grade_this({
  code <- .user_code

  # 0) Empty/untouched?
  if (!nzchar(gsub("\\s|#.*", "", code))) {
    fail("Type your answer in the editor.")
  }

  # 1) Find the student's env (webR/gradethis names vary)
  env <- get0(".envir_result", ifnotfound = NULL)
  if (is.null(env)) env <- get0(".user_env", ifnotfound = NULL)
  if (is.null(env)) env <- parent.frame()

  # 2) Get their function (prefer the named binding; fall back to .result)
  f <- NULL
  if (exists("divide_nums", envir = env, inherits = FALSE)) {
    f <- get("divide_nums", envir = env)
  } else if (is.function(.result)) {
    f <- .result
  }

  if (!is.function(f)) {
    fail("Define a function named `divide_nums(a, b)` (use `divide_nums <- function(a, b) { ... }`).")
  }

  # 3) Run it and grade
  val <- tryCatch(f(8, 2), error = function(e) e)
  if (inherits(val, "error")) {
    msg <- conditionMessage(val)
    if (grepl("object .* not found", msg)) {
      fail("Looks like you referenced a variable that wasn’t created (e.g., `res1` or `res2`).")
    } else {
      fail(paste0("Your function raised an error: ", msg))
    }
  }

  if (!is.list(val) || length(val) != 2) {
    fail("Return a **list** of two elements: `list(res1, res2)`.")
  }
  if (!(is.numeric(val[[1]]) && is.numeric(val[[2]]))) {
    fail("Both returned values must be numeric (`a/b` and `b/a`).")
  }

  ok <- isTRUE(all.equal(val[[1]], 4,    tol = 1e-8)) &&
        isTRUE(all.equal(val[[2]], 0.25, tol = 1e-8))
  if (!ok) {
    fail("Close! Compute `res1 <- a / b` and `res2 <- b / a`, then return `list(res1, res2)`.")
  }

  pass("✅ Well done! Function name, outputs, and return format are correct.")
})
```

## Q3 — Draw a histogram from `cars` (type the full call)

Use **exactly one** of these numeric columns and nothing else:  
dist  **or**  speed

```{webr}
#| exercise: ex_hist_exact
# Type your answer on the next line (one command only):
```

::: {.solution exercise="ex_hist_exact"}
```{webr}
#| exercise: ex_hist_exact
#| solution: true
hist(cars$dist)
```
:::

```{webr}
#| exercise: ex_hist_exact
#| check: true
gradethis::grade_this({
  # Grab what they typed (keep it robust)
  code <- .user_code
  lines <- strsplit(code, "\n", fixed = TRUE)[[1]]
  # strip comments per-line, then trim and drop empties
  lines <- sub("#.*$", "", lines)
  trim  <- function(s) sub("^\\s+|\\s+$", "", s)
  lines <- trim(lines)
  lines <- lines[nzchar(lines)]

  if (length(lines) == 0) {
    fail("Type your answer, it cant be empty.")
  }
  if (length(lines) > 1) {
    fail("Enter exactly **one** command.")
  }

  one <- lines[1]
  # Did it actually draw a histogram?
  if (!inherits(.result, "histogram")) {
    fail("Your code should draw a histogram.")
  }

  # Normalize spaces for exact-match check
  normalized <- gsub("\\s+", "", one)

  if (normalized %in% c("hist(cars$dist)", "hist(cars$speed)")) {
    pass("✅ Correct!")
  } else if (grepl("^hist\\s*\\(\\s*cars\\s*\\)\\s*$", one)) {
    fail("`hist(cars)` won’t work—choose a numeric column: hist(cars$dist) or hist(cars$speed).")
  } else if (grepl("^hist\\s*\\(", one)) {
    fail("For this question, type exactly `hist(cars$dist)` or `hist(cars$speed)` (and nothing else).")
  } else {
    fail("Use `hist(...)` with a column from `cars`.")
  }
})
```
